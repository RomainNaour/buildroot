From 2a735f52ec321f06b2af4b4265160d54260e5c44 Mon Sep 17 00:00:00 2001
From: Romain Naour <romain.naour@gmail.com>
Date: Sun, 15 Oct 2017 20:04:24 +0200
Subject: [PATCH] Provide a C++ version of signbit that does not use __MATH_TG
 (bug 22296)

The macro __MATH_TG contains the logic to select between long double and
_Float128, when these types are ABI-distinct.  This logic relies on
__builtin_types_compatible_p, which is not available in C++ mode.

On the other hand, C++ function overloading provides the means to
distinguish between the floating-point types.  The overloading
resolution will match the correct parameter regardless of type
qualifiers, i.e.: const and volatile.

This is the same fix as for issignaling [1] but the issue appear
only with gcc < 6.x. Since GCC 6.0, __builtin_signbit is type-generic,
so signbit() is defined without __MATH_TG.

Tested for x86_64.

	* math/math.h [defined __cplusplus] (signbit): Provide a C++
	definition for signbit that does not rely on __MATH_TG,
	since __MATH_TG uses __builtin_types_compatible_p, which is only
	available in C mode.

[1] a16e8bc08edca84d507715c66d6cddbbc7ed3b62

Signed-off-by: Romain Naour <romain.naour@gmail.com>
---
patch status: submited upstream
https://sourceware.org/ml/libc-alpha/2017-10/msg00654.html
---
 math/math.h | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/math/math.h b/math/math.h
index 2b216c6..0013ad9 100644
--- a/math/math.h
+++ b/math/math.h
@@ -418,6 +418,21 @@ enum
 /* Return nonzero value if sign of X is negative.  */
 # if __GNUC_PREREQ (6,0)
 #  define signbit(x) __builtin_signbit (x)
+# elif defined __cplusplus
+   /* In C++ mode, __MATH_TG cannot be used, because it relies on
+      __builtin_types_compatible_p, which is a C-only builtin.  On the
+      other hand, overloading provides the means to distinguish between
+      the floating-point types.  The overloading resolution will match
+      the correct parameter (regardless of type qualifiers (i.e.: const
+      and volatile).  */
+extern "C++" {
+inline int signbit (float __val) { return __signbitf (__val); }
+inline int signbit (double __val) { return __signbit (__val); }
+inline int signbit (long double __val) { return __signbitl (__val); }
+#  if __HAVE_DISTINCT_FLOAT128
+inline int signbit (_Float128 __val) { return __signbitf128 (__val); }
+#  endif
+} /* extern C++ */
 # elif __GNUC_PREREQ (4,0)
 #  define signbit(x) __MATH_TG ((x), __builtin_signbit, (x))
 # else
-- 
2.9.5

